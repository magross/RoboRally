\documentclass[a4paper,12pt]{article}
% Umlaute, Sonderzeichen, etc.
\usepackage[german]{babel}
\usepackage[latin1]{inputenc}
% Header & Footer 
\usepackage{fancyhdr}
% Mathematik
% AMSMATH
% centertags,tbtags
% sumlimits,nosumlimits
% intlimits,nointlimits
% namelimits,nonamelimits
% leqno,reqno,fleqn
\usepackage[centertags,sumlimits,intlimits,namelimits,fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}

\usepackage{amsthm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem*{defn}{Definition}
\newtheorem*{satz}{Proposition}
\newtheorem*{proposition}{Proposition}
\newtheorem*{theorem}{Theorem}
\newtheorem*{lemma}{Lemma}
\newtheorem*{kor}{Corollary}
\newtheorem*{corollary}{Corollary}
\newtheorem*{algorithm}{Algorithm}

\newtheorem*{cayley}{Theorem of Cayley}
\newtheorem*{prim}{Prim's Algorithm}
\newtheorem*{kruskal}{Kruskal's Algorithm}
\newtheorem*{edmonds}{Edmonds's Algorithm}
\newtheorem*{dijkstra}{Dijkstra's Algorithm}
\newtheorem*{moore}{Moore-Bellman-Ford Algorithm}

\theoremstyle{remark}
\newtheorem*{bem}{Remark}
\newtheorem*{difficulties}{Difficulities}
\newtheorem*{goal}{Goal}
\newtheorem*{remark}{Remark}
\newtheorem*{remarks}{Remarks}
\newtheorem*{claim}{Claim}
\newtheorem*{repetition}{Repetition}
\newtheorem*{solution}{Solution}
\newtheorem*{example}{Example}
\newtheorem*{examples}{Examples}
\newtheorem*{improvement}{Improvement}
\newtheorem*{observation}{Observation}
\newtheorem*{assumption}{Assumption}
\newtheorem*{question}{Question}
\newtheorem*{answer}{Answer}
\newtheorem*{idea}{Idea}

\newcommand{\problem}[4]{
 ~\\
 \framebox{
  \parbox{#4\textwidth}{
   \vspace{1mm}
   {\large\textsc{#1}}\\[2mm]
   \begin{tabular}{p{0.1\textwidth}p{0.81\textwidth}}
   \emph{Instance}: & \parbox{\linewidth}{#2}\\[2mm]
   \emph{Task}:     & \parbox{\linewidth}{#3}
   \end{tabular}
  }
  \\
 }
}

\newcommand{\algpr}[3]{
% \newline
 \framebox{
  \parbox{0.97093\textwidth}{
   \vspace{1mm}
   {\large\textsc{#1}}\\[2mm]
   \begin{tabular}{p{0.1\textwidth}p{0.81\textwidth}}
   \emph{Instance}: & \parbox{\linewidth}{#2}\\[2mm]
   \emph{Task}:     & \parbox{\linewidth}{#3}
   \end{tabular}
  }
  \\
 }
}

\newcommand{\algor}[4]{
 \framebox{
  \parbox{0.97093\textwidth}{
   \vspace{1mm}
   {\large\textsc{#1}}\\[2mm]
   \begin{tabular}{p{0.1\textwidth}p{0.81\textwidth}}
   \emph{Input}:  & #2\\[2mm]
   \emph{Output}: & #3\\[2mm]
   #4
   \end{tabular}
  }
  \\
 }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{pst-node}

%\usepackage{enumerate}
\usepackage{graphicx}
%\usepackage{pstricks,pst-plot}
%\usepackage{float}

% Textareal destlegen
\setlength{\textheight}{254mm}
\setlength{\textwidth}{160mm}

\setlength{\oddsidemargin}{0mm}
\setlength{\topmargin}{-15mm}

% Erste Zeile eines Paragraphen nicht einrücken
\setlength{\parindent}{0mm}

% Header & Footer festlegen
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{14pt}
\lhead{}
\chead{}
\rhead{}
\lfoot{}
\cfoot{}
\rfoot{}

\renewcommand\floatpagefraction{.99}
\renewcommand\textfraction{.01}
\setcounter{totalnumber}{10}


%%%%%%%%%%%%%%%%
% Formatierung %
%%%%%%%%%%%%%%%%

\newcounter{exercises}
\setcounter{exercises}{4}
% Aufgabe
\newcommand{\aufgabe}{
 \stepcounter{exercises}
 \par
 \vspace{6mm}
 \textbf{Aufgabe \arabic{exercises}:}
}

%%%%%%%%%%%%%
% Mathemodi %
%%%%%%%%%%%%%

  \DeclareMathOperator{\OPT}{OPT}

% Abkürzungen für Aligned-Mathemodus (anfang mathe / ende mathe) 
\newcommand{\ama}{\[ \begin{aligned}}
\newcommand{\ema}{\end{aligned} \]}

%%%%%%%%%%%%%%
% Buchstaben %
%%%%%%%%%%%%%%

% Abkürzung für das andere Epsilon
\newcommand{\eps}{\varepsilon}


%%%%%%%%%
% Logik %
%%%%%%%%%

% Abkürzungen für logische Operatoren (for all / equivalent / exists / implies)
\newcommand{\all}{\forall}
\newcommand{\eq}{\Leftrightarrow}
\newcommand{\ex}{\exists}
\newcommand{\impl}{\Rightarrow}

%%%%%%%%%%
% Mengen %
%%%%%%%%%%

% Kardinalität einer Menge (Cardinality)
\newcommand{\card}[1]{\left| #1 \right|}
% Menge (Set)
\newcommand{\set}[1]{\left\{#1\right\}}
% Menge, die durch eine Eigenschaft definiert ist (set defined by condition)
\newcommand{\setc}[2]{\left\{\left.#1\ \right|\ #2\right\}}
% Potenzmenge
\newcommand{\pot}[1]{\mathcal{P}(#1)}
% Die Standard-Zahlenmengen
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
% Wenn es egal ist, ob R oder C:
\newcommand{\K}{\mathbb{K}}
% R und +/- unendlich
\newcommand{\RI}{\hat{\R}}
% Menge der Lebesgue-Integrierbaren Funktionen (L)
\newcommand{\Leb}{\mathcal{L}}
% Rand (Border) einer Menge
\newcommand{\border}[1]{\partial #1}
\newcommand{\rand}[1]{\border{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Vektoren, Matrizen, Determinaten % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Matrix
\newcommand{\matr}[1]{\begin{pmatrix}#1\end{pmatrix}}
% Determinate
\newcommand{\deter}[1]{\begin{vmatrix}#1\end{vmatrix}}
% Vektor
\newcommand{\vect}[1]{\matr{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abbildungen / Funktionen %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Absolut-Betrag (absolute value)
\newcommand{\abs}[1]{\left| #1 \right|}
% Untere Gaußklammern (floor) 
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
% Obere Gaußklammern (ceiling) 
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
% Komplex konjugiert (Complex conjugate)
\newcommand{\cc}[1]{\overline{#1}}
% Norm (norm) 
\newcommand{\norm}[1]{\left|\!\left|#1\right|\!\right|}
% Unendlich / Maximums / Supremumsnorm (uniform / infinity / maximum / supremum / Chebyshev norm)
\newcommand{\maxnorm}[1]{\left|\!\left|#1\right|\!\right|_\infty}
\newcommand{\supnorm}[1]{\left|\!\left|#1\right|\!\right|_\infty}
% p-Norm
\newcommand{\pnorm}[1]{\left|\!\left|#1\right|\!\right|_p}
% Spur einer Kurve
\DeclareMathOperator{\spur}{spur}
\DeclareMathOperator{\pred}{pred}
\DeclareMathOperator{\excess}{ex}
\DeclareMathOperator{\cost}{cost}
\DeclareMathOperator{\dist}{dist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Differenziale & Integrale %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Partielle Ableitung / Partielle Ableitung am Punkt x
\newcommand{\pdiff}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pdiffx}[3]{\left.\frac{\partial #1}{\partial #2}\right|_{#3}}
% Hesse-Matrix
\newcommand{\hesse}{\mathcal{H}}
% Ausgewertet bei
\newcommand{\eval}[3]{\left.\left(#1\right)\right|_{#2}^{#3}}
% Wegintegral (path integral)
\newcommand{\pathint}[1]{\int_{[#1]}}
\newcommand{\wegint}[1]{\int_{[#1]}}
% Integral-Operatoren
\newcommand{\intoperator}[1]{\ \operatorname{d#1}}
% 1-dimensionale Integral-Operatoren
\newcommand{\dt}{\intoperator{t}}
\newcommand{\du}{\intoperator{u}}
\newcommand{\dx}{\intoperator{x}}
\newcommand{\dy}{\intoperator{y}}
\newcommand{\dz}{\intoperator{z}}
% 2-dimensionale Integral-Operatoren
\newcommand{\dxy}{\intoperator{(x,y)}}

\newcommand{\st}{\operatorname{s.t.}}

\newcommand{\rg}{\operatorname{rg}}

\newcommand{\back}[1]{\stackrel{\leftarrow}{#1}}
\newcommand{\bi}[1]{\stackrel{\leftrightarrow}{#1}}

\newcommand{\lp}[3]{
 \ama
  & \!\!\!\!\!\!\!\! #1\\
  & \!\!\!\!\!\!\!\! \text{subject to}\\
  #2\\
  & #3
 \ema
} 

\usepackage{listings,tikz}

\newcommand{\ap}[2]{\emph{Given:} #1\\\emph{Task:} #2}

\newcommand{\algo}[2]{\emph{Input:} #1\\\emph{Output:} #2}

   \tikzstyle{sourceNode}=[draw, circle, shade, color=black, ball color = green!70, inner sep = 0.1em, minimum size = 0.5cm]
   \tikzstyle{sinkNode}=[draw, circle, shade, color=black, ball color = red!70, inner sep = 0.1em, minimum size = 0.5cm]
   \tikzstyle{normalNode}=[draw, circle, shade, color=black, ball color = blue!70, inner sep = 0.1em, minimum size = 0.5cm]
   \tikzstyle{normalEdge}=[<-, line width=0.075cm, >=stealth]

\newcommand{\clientmessage}[5]{
  \begin{table}
   \begin{tabular}{|ll|}
    \hline
    \multicolumn{2}{|l|}{\large\texttt{#1}}\\
    \hline
    \emph{Parameter}: & #2\\
    \hline
    \emph{Wann zulässig}: & #3\\
    \hline    
    \multicolumn{2}{|l|}{\parbox{0.97093\textwidth}{\vspace{2mm}#4\vspace{2mm}}}\\
    \hline
    \emph{Beispiel}: & \parbox{0.76\textwidth}{\texttt{#5}}\\
    \hline
   \end{tabular}   
  \end{table}
}

\usepackage{tabls,url}

\begin{document}

 \section{Server}
 
  Den Server erhaltet ihr über die CoMa-Homepage \url{http://www.math.tu-berlin.de/CoMa/coma2.SS10/} oder über das CoMa-Forum \url{http://www.math.tu-berlin.de/CoMa/forum/cgi-bin/yabb2/YaBB.pl}. Der Server besteht nur aus einer einzigen Datei, die ihr je nach System per Doppelklick oder per Kommandozeile mit \texttt{java -jar Server.jar} starten könnt. Beim Aufruf über die Kommandozeile könnt ihr einige optionale Parameter festlegen:
  
  \begin{table}[h]
   \centering
   \begin{tabular}{|l|l|l|}    
    \hline
     & Bedeutung & Standardwert\\
    \hline
    1. Parameter & Port, auf dem der Server auf Clienten wartet & 4444\\
    \hline
    2. Parameter & Maximale Anzahl gleichzeitiger Verbindungen & 50\\
    \hline
    3. Parameter & Passwort für die Clienten & Keins\\
    \hline
    4. Parameter & Begrüßungsnachricht des Server an die Clienten & Willkommen!\\
    \hline   
   \end{tabular}
  \end{table} 
  
  Wird als Passwort "`"' angegeben, wird von den Clienten kein Passwort gefordert. Leerzeichen zu Beginn und am Ende des Passworts werden ignoriert, die Groß- \& Kleinschreibung wird aber beachtet. Ein Aufruf des Servers ohne Parameter entspricht dem folgenden Aufruf:
  \[
   \text{\texttt{java -jar Server.jar 4444 50 "" Willkommen!}}
  \]
  
  \subsection{Kommunikation}
  
  Die Kommunikation zwischen Server und Clienten läuft über Textnachrichten ab, die mittels TCP verschickt werden. Eine Nachricht besteht dabei aus einer Textzeile, die durch \texttt{|} Zeichen in einen oder mehrere Abschnitte untergliedert ist. Der erste Abschnitt bestimmt die Art der Nachricht, alle weiteren Abschnitte sind Parameter, die von der Art der Nachricht abhängen.
  
  Der Server begrüßt einen Clienten nach der Verbindung mit   
  \[
   \text{\texttt{WELCOME | <Begrüßungsnachricht>}}
  \]
  und
  \[
   \text{\texttt{AWAITING\_REGISTRATION}}
  \]
  Danach kann sich der Client vorstellen und einen Namen registrieren, wie im Abschnitt \emph{Nachrichten an den Server} beschrieben ist.
  
  Erkennt der Server die Art einer Nachricht (d.h. den ersten Abschnitt der Nachricht) nicht, antwortet er mit
  \[
   \text{\texttt{UNKNOWN\_MESSAGE | <Erster Abschnitt>}}
  \]
  Ist die Art der Nachricht zum aktuellen Zeitpunkt unpassend, antwortet der Server mit
  \[
   \text{\texttt{MESSAGE\_NOT\_ALLOWED\_IN\_CURRENT\_STATE | <Erster Abschnitt>}}
  \]
  Hat die Nachricht zu wenige oder zu viele Nachrichten, schickt der Server
  \[
   \text{\texttt{INCORRECT\_NUMBER\_OF\_PARAMETERS | <Min> | <Max> | <Geschickt>}}
  \]
  wobei \texttt{<Min>} und \texttt{<Max>} jeweils die minimal und maximal zulässige Anzahl von Parametern für diese Art von Nachricht sind und \texttt{<Geschickt>} die vom Client geschickte Anzahl.

 \subsection{Nachrichten an den Server}
 
 Der Server akzeptiert die folgenden Nachrichten:
 
 \begin{itemize}
  \item \texttt{INTRODUCE}
  \item \texttt{REGISTER}
  \item \texttt{SEND\_SERVER\_MESSAGE}
  \item \texttt{SEND\_GAME\_MESSAGE}
  \item \texttt{SEND\_PRIVATE\_MESSAGE}
  \item \texttt{ECHO}
  \item \texttt{LIST\_GAME\_PLAYERS}
  \item \texttt{LIST\_GAMES}
  \item \texttt{LIST\_PLAYERS}
  \item \texttt{LIST\_REPLAYS}
  \item \texttt{LIST\_SCENARIOS}
  \item \texttt{GET\_GAME}
  \item \texttt{GET\_REPLAY}
  \item \texttt{GET\_SCENARIO}
  \item \texttt{CREATE\_GAME}
  \item \texttt{JOIN\_GAME}
  \item \texttt{START\_GAME}
  \item \texttt{CLOSE\_CONNECTION}
%   \item \texttt{ab hier Madeleines Liste}
%     GAME("%1$s | %2$s | %3$s | %4$s"),
%     JOINING\_FAILED("%1$s"),
%     PLAYER\_JOINED("%1$s"),
%     PLAYER\_ARRIVED("%1$s"),
%     PLAYER\_DESTROYED("%1$s"),
%     NOT\_WAITING\_FOR\_THIS\_CHOICE("%1$s"),
%     UNKNOWN\_CHOICE("%1$s"),
%     CHOOSE {
%     TIMEOUT("%1$s | %2$s"),ILLEGAL_CHOICE,NEW_PHASE("%1$s"),EXECUTING_PROGRAMS,EXECUTING_PROGRAM_CARD("%1$s"),
% 
%     GAME\_OVER("%1$s") {
%     CHOSEN {
% 
% EFFECT\_OCCURRED("%1$s"),ROBOT_STATUS("%1$s"),
%     ADMIN\_PRIVILEGES\_DENIED,
%     ADMIN\_PRIVILEGES\_GRANTED,
%     SAVES("%1$s"),
%     GAMES("%1$s"),
%     SCENARIOS("%1$s"),
%     REPLAYS("%1$s"),
%     REPLAY("%1$s"),
%     REPLAY\_NOT\_FOUND,
%     SCENARIO("%1$s"),
%     GAME\_CREATED("%1$s"),
%     GAME\_PLAYERS("%1$s"),
%     GAME\_STATUS("%1$s"),
%     PLAYER\_LEFT("%1$s"),
%     NEW\_TURN("%1$s"),
%     AWAITING\_REGISTRATION,
%     CONNECTION\_CLOSED("%1$s"),
%     GAME\_CHAT\_MESSAGE("%1$s | %2$s"),
%     INCORRECT\_NUMBER\_OF\_PARAMETERS("%1$s | %2$s | $3$s"),
%     INTRODUCTION\_SUCCESSFUL,
%     MESSAGE\_NOT\_ALLOWED\_IN\_CURRENT\_STATE,
%     NAME\_ALREADY\_IN\_USE,
%     NO\_MESSAGE,
%     PLAYER\_LEFT,
%     PLAYER\_KICKED("%1$s | %2$s"),
%     PLAYER\_NOT\_FOUND("%1$s"),
%     GAME\_NOT\_FOUND("%1$s"),
%     GAME\_STARTED("%1$s"),
%     GAME\_IS\_ALREADY\_RUNNING,
%     PRIVATE\_CHAT\_MESSAGE("%1$s | %2$s | %3$s"),
%     PLAYERS("%1$s"),
%     REGISTRATION\_DENIED,
%     REGISTRATION\_SUCCESSFUL,
%     SCENARIO\_NOT\_FOUND("%1$s"),
%     SERVER\_ACCESS\_DENIED,
%     SERVER\_CHAT\_MESSAGE("%1$s | %2$s"),
%     UNKNOWN\_MESSAGE("%1$s"),
%     WELCOME("%1$s");
%        AUTHOR("Author:"),
%         COURSE("Course:"),
%         DESCRIPTION("Description:"),
%         DIFFICULTY("Difficulty:"),
%         HEIGHT("Height:"),
%         LENGTH("Length:"),
%         MAX\_PLAYERS("Max. Players:"),
%         MIN\_PLAYERS("Min. Players:"),
%         NAME("Name:"),
%         WIDTH("Width:");
%     UNKOWN\_CHOICE,
%   	TURN\_AROUND
%      ROTATE\_LEFT,
%      ROTATE\_RIGHT,
%      BACKMOVE\_1,
%      MOVE\_2, 
%      MOVE\_3, 
% EXECUTING\_PROGRAM\_CARD,
%          GAME\_STARTED, name,
%          GAME\_PLAYERS, players,
%          GAME\_STATUS, 
%          EXECUTING\_PROGRAMS,
%          NEW\_PHASE,
%          PLAYER\_DESTROYED,
%          PLAYER\_ARRIVED,
%          EFFECT\_OCCURRED,
%          ROBOT\_STATUS,
%          BOARD\_ELEMENT\_MOVE,
% 				 LASER\_FIRE,
% 				 TOUCH\_CHECKPOINT,
% 		\item Client Messages
% 		INTRODUCE,
% 		CLOSE\_CONNECTION,
% 		REGISTER,
% 		LIST\_GAMES,
% 		LIST\_PLAYERS,
% 		LIST\_REPLAYS,
% 		LIST\_SCENARIOS,
% 		LIST\_GAME\_PLAYERS,
% 		GET\_GAME,
% 		GET\_REPLAY,
% 		GET\_SCENARIO,
% 		SEND\_PRIVATE\_MESSAGE,
% 		ECHO,
% 		SEND\_SERVER\_MESSAGE,
% 		CREATE\_GAME,
% 		START\_GAME,
% 		JOIN\_GAME,
% 		GAME\_CHOICE,
% 		SEND\_GAME\_MESSAGE,
% 		CHOOSE,
% 		    ANNOUNCE\_POWER\_DOWN,
%         PROGRAMMING(Visibility.RESULT\_ONLY),
%         REMAIN\_POWERED\_DOWN,
%         SPAWN\_TILE,
%         SPAWN\_DIRECTION;
% 	\item m\"ogliche Antworten darauf
% 	INTRODUCTION\_SUCCESSFUL,
% 	SERVER\_ACCESS\_DENIED,
% 	CONNECTION\_CLOSED, "As requested by client.",
% 	REGISTRATION\_SUCCESSFUL,
% 	NAME\_ALREADY\_IN\_USE,
% 	REGISTRATION\_DENIED,
% 	GAMES,
% 	PLAYERS,
% 	REPLAYS,
% 	SCENARIOS,
% 	GAME\_NOT\_FOUND,
% 	GAME\_PLAYERS,
% 	GAME,
% 	REPLAY\_NOT\_FOUND,
% 	REPLAY,
% 	SCENARIO\_NOT\_FOUND,
% 	SCENARIO,
% 	PLAYER\_NOT\_FOUND,
% 	GAME\_CREATED,
% 	GAME\_IS\_ALREADY\_RUNNING,
% 	JOINING\_FAILED,
% 	NO\_MESSAGE,
% 	UNKNOWN\_MESSAGE,
% 	MESSAGE\_NOT\_ALLOWED\_IN\_CURRENT\_STATE,
% 	INCORRECT\_NUMBER\_OF\_PARAMETERS,
% 	NOT\_WAITING\_FOR\_THIS\_CHOICE,
% 	CHOSEN,

     
 \end{itemize}
 
 Die genaue Syntax und Semantik dieser Nachrichten wird auf den folgenden Seiten beschrieben.
\clearpage 
      
  \clientmessage
  {INTRODUCE | <Clienttyp> | <Passwort>}
  {1-2}
  {Wenn noch nicht vorgestellt}
  { Stellt euren Client dem Server vor. Der Parameter \texttt{<Clienttyp>} ist ein beliebiger String, der euren Clienten beschreibt, z.B. \texttt{Client der Gruppe 107}. Es können mehrere Clienten des selben Typs gleichzeitig mit dem Server verbunden sein. Der Parameter \texttt{<Passwort>} ist optional und muss nur angegeben werden, wenn der Zugang zum Server durch ein Passwort geschützt ist. Das Passwort muss die korrekte Groß- \& Kleinschreibung aufweisen, Leerzeichen am Anfang und Ende des Passwortes werden ignoriert. Der Server sendet
    \[
     \text{\texttt{INTRODUCTION\_SUCCESSFUL}}
    \]
    wenn die Vorstellung erfolgreich verlaufen ist, anderenfalls sendet er: 
    \[
     \text{\texttt{SERVER\_ACCESS\_DENIED}}
    \]
    Dieser Fall tritt nur dann ein, wenn der Server passwortgeschützt ist und ein falsches Passwort angegeben wurde. }
  {INTRODUCE | Client der Gruppe 001\\INTRODUCE | Client X | Furchtbar geheimes Passwort}
  
 \clientmessage
 {REGISTER | <Spielername>}
 {1}
 {Nach der Vorstellung, solange noch kein Name registriert wurde}
 { Registriert beim Server einen Namen für euren Clienten, der vom Server benutzt wird, euch zu identifizieren. Andere Clienten können euch mit Hilfe dieses Namens Nachrichten schicken, wenn sie mit demselben Server verbunden sind. Dieser Name muss innerhalb des Servers eindeutig sein; benutzt ein anderer Client bereits den von euch gewünschten Namen, antwortet der Server mit
 \[
  \text{\texttt{NAME\_ALREADY\_IN\_USE}}
 \]
 Wird der Name noch nicht benutzt, antwortet der Server mit
 \[
  \text{\texttt{REGISTRATION\_SUCCESSFUL}}
 \] 
 Eine Liste aktuell schon vergegeben Namen könnt ihr mit \texttt{LIST\_PLAYERS} erhalten.
 }
 {REGISTER | Marvin}

  \clientmessage
  {CLOSE\_CONNECTION}
  {Keine}
  {Immer}
  {Trennt die Verbindung mit dem Server. Nimmt der Client gerade an einem Spiel teil, verlässt der Client das Spiel und die Spieler erhalten eine Nachricht der Form:
    \[
     \text{\texttt{PLAYER\_LEFT | <Spielername>}}
    \]
    Der Client selbst erhält die Nachricht
    \[
     \text{\texttt{CONNECTION\_CLOSED | As requested by client.}}
    \]
    Der vom Client benutzte Name wird vom Server wieder zur Benutzung freigegeben.
  }
  {CLOSE\_CONNECTION}

 \clientmessage
 {SEND\_SERVER\_MESSAGE | <Nachricht>}
 {1}
 {Sobald ein Name registriert wurde}
 { Schickt die spezifizierte Nachricht an alle auf dem Server registrierten Spieler. Der Server schickt sie in der Form 
 \[
  \text{\texttt{SERVER\_CHAT\_MESSAGE | <Sender> | <Nachricht>}}
 \]
 an alle Spieler weiter.
 }
 {SEND\_SERVER\_MESSAGE | Hallo Welt!}

 \clientmessage
 {SEND\_GAME\_MESSAGE | <Nachricht>}
 {1}
 {Wenn man ein Spiel spielt}
 { Schickt die spezifizierte Nachricht an alle Spieler, die gerade mit dem Client spielen. Der Server schickt sie in der Form 
 \[
  \text{\texttt{GAME\_CHAT\_MESSAGE | <Sender> | <Nachricht>}}
 \]
 an diese Spieler weiter.
 }
 {SEND\_GAME\_MESSAGE | Hallo Welt!}

 \clientmessage
 {SEND\_PRIVATE\_MESSAGE | <Spielername> | <Nachricht>}
 {2}
 {Wenn man auf dem Server registriert ist}
 { Schickt die spezifizierte Nachricht an den Spieler mit dem angegebenen Namen. Ist auf dem Server kein Spieler mit diesem Namen registriert, antwortet der Server mit
 \[
  \text{\texttt{PLAYER\_NOT\_FOUND}}
 \]
 Anderenfalls leitet der Server die Nachricht in der Form
 \[
  \text{\texttt{PRIVATE\_CHAT\_MESSAGE | <Sender> | <Empfänger> | <Nachricht>}}
 \]
 an Sender und Emfänger weiter.
 }
 {SEND\_PRIVATE\_MESSAGE | Marvin | Don't panic!}

 \clientmessage
 {ECHO | <Nachricht>}
 {1}
 {Wenn man auf dem Server registriert ist}
 { Schickt die spezifizierte Nachricht an sich selbst. Dieser Befehl ist eine Abkürzung für 
 \[
  \text{\texttt{SEND\_PRIVATE\_MESSAGE | <Sender> | <Nachricht>}}
 \]
 entsprechend schickt der Server
 \[
  \text{\texttt{PRIVATE\_CHAT\_MESSAGE | <Sender> | <Sender> | <Nachricht>}}
 \] 
 zurück.
 }
 {ECHO | Echooooooo}

 \clientmessage
 {LIST\_PLAYERS}
 {0}
 {Wenn man auf dem Server vorgestellt ist}
 { Fragt eine Liste der aktuell auf dem Server registrierten Spieler ab. Der Server schickt sie in der Form
 \[
  \text{\texttt{PLAYERS | <Spieler1> | <Spieler2> | ...}}
 \]
 an den Client. \texttt{SpielerX} ist dabei der Name eines Spielers.
 }
 {LIST\_PLAYERS}

 \clientmessage
 {LIST\_GAMES}
 {0}
 {Wenn man auf dem Server registriert ist}
 { Fragt eine Liste der aktuell auf dem Server existierenden Spiele ab. Der Server schickt sie in der Form
 \[
  \text{\texttt{GAMES | <Spiel1> | <Spiel2> | ...}}
 \]
 an den Client. \texttt{SpielX} ist dabei der Name eines Spiels.
 }
 {LIST\_GAMES}

 \clientmessage
 {LIST\_SCENARIOS}
 {0}
 {Wenn man auf dem Server registriert ist}
 { Fragt eine Liste der aktuell auf dem Server verfügbaren Szenarien ab, aus denen Spiele erstellt werden können. Der Server schickt sie in der Form
 \[
  \text{\texttt{SCENARIO | <Szenario1> | <Szenario2> | ...}}
 \]
 an den Client. \texttt{SzenarioX} ist dabei der Name eines Szenarios.
 }
 {LIST\_SCENARIOS}
 
 \clientmessage
 {LIST\_REPLAYS}
 {0}
 {Wenn man auf dem Server registriert ist}
 { Fragt eine Liste der aktuell auf dem Server gespeicherten Replays ab. Ein Replay stellt dabei ein Protokoll eines auf dem Server geführten Spiels dar. Replays werden vom Server automatisch nach Spielende erzeugt, sofern ein Spiel nicht vorzeitig beendet wurde.
 \[
  \text{\texttt{REPLAYS | <Replay1> | <Replay2> | ...}}
 \]
 an den Client. \texttt{ReplayX} ist dabei der Name eines Replays, welcher sich aus dem Name des Spiels und Datum \& Zeit, zu der das Spiel beendet wurde, zusammensetzt. 
 }
 {LIST\_REPLAYS} 

 \clientmessage
 {LIST\_GAME\_PLAYERS | <Spielname>}
 {1}
 {Wenn man auf dem Server registriert ist}
 { Fragt eine Liste der Spieler ab, die dem angegebenen Spiel beigetreten sind. Existiert kein Spiel mit dem angegebenen Namen, antwortet der Server mit
 \[
  \text{\texttt{GAME\_NOT\_FOUND | <Spielname>}}
 \]
 Anderenfalls wird die Liste in der Form
 \[
  \text{\texttt{GAME\_PLAYERS | <Spieler1> | <Spieler2> | ...}}
 \]
 an den Client geschickt. \texttt{SpielerX} ist dabei der Name eines Spielers.
 }
 {LIST\_GAME\_PLAYERS | CoMa-Testspiel}

 \clientmessage
 {GET\_GAME | <Spielname>}
 {1}
 {Wenn man auf dem Server registriert ist}
 { Fragt ein auf dem Server existierendes Spiel ab. Existiert kein Spiel mit dem angegebenen Namen, antwortet der Server mit
 \[
  \text{\texttt{GAME\_NOT\_FOUND | <Spielname>}}
 \]
 Anderenfalls werden Informationen über das Spiel in der Form
 \[
  \text{\texttt{GAME | <Szenario> | <Akt. \# Spieler> | <Max. \# Spieler> | <Laufend?>}}
 \]
 geschickt. \texttt{<Szenario>} ist dabei der Name des Szenarios, auf dem das Spiel basiert, \texttt{<Akt. \# Spieler>} und \texttt{<Max. \# Spieler>} sind die aktuelle und die maximale Anzahl Spieler für das Spiel und \texttt{<Laufend?>} gibt an, ob man dem Spiel noch beitreten kann oder nicht.
 }
 {GET\_GAME | CoMa-Testspiel} 

 \clientmessage
 {GET\_REPLAY | <Replayname>}
 {1}
 {Wenn man auf dem Server registriert ist}
 { Fragt ein auf dem Server gespeichertes Replay ab. Existiert das gewünschte Replay nicht, antwortet der Server mit
 \[
  \text{\texttt{REPLAY\_NOT\_FOUND | <Replayname>}}
 \]
 Anderenfalls wird das Replay in der Form
 \[
  \text{\texttt{REPLAYS | <Replay-Daten>}}
 \]
 an den Client geschickt, wo bei die \texttt{Replay-Daten} alle vom Server geschickten Spiel-Nachrichten sind, jeweils durch \texttt{||} getrennt. 
 }
 {GET\_REPLAY | Blubb (28.04.10 12:30:18)} 

 \clientmessage
 {CREATE\_GAME | <Szenarioname> | <Spielname> }
 {2}
 {Wenn man auf dem Server registriert ist und gerade nicht spielt}
 { Erzeugt ein neues Spiel mit dem angegebenen Namen basierend auf dem angegebenen Szenario. Der Spielname muss serverweit eindeutig sein, wird der Name schon benutzt, antwortet der Server mit
 \[
  \text{\texttt{NAME\_ALREADY\_IN\_USE | <Spielname>}}
 \]
 Existiert das angegebene Szenario nicht, wird
 \[
  \text{\texttt{SCENARIO\_NOT\_FOUND | <Szenarioname>}}
 \] 
 zurückgegeben. Anderenfalls tritt der Client dem erzeugten Spiel bei und es wird an alle registrierten Spieler
 \[
  \text{\texttt{GAME\_CREATED | <Spielname>}}
 \] 
 geschickt.
 }
 {CREATE\_GAME | Risky Exchange | CoMa-Testspiel} 

 \clientmessage
 {JOIN\_GAME | <Spielname> }
 {1}
 {Wenn man auf dem Server registriert ist und gerade nicht spielt}
 { Tritt dem Spiel bei, sofern noch Plätze frei sind und das Spiel nicht bereits läuft. Findet der Server kein Spiel mit dem angegebenen Namen, wird
 \[
  \text{\texttt{GAME\_NOT\_FOUND | <Spielname>}}
 \]
 zurückgegeben. Läuft das Spiel bereits, oder sind alle Plätze besetzt, antwortet der Server mit
 \[
  \text{\texttt{JOINING\_FAILED | <Spielname>}}
 \] 
 Anderenfalls erhalten der Client und alle weiteren Spieler, die dem Spiel bisher beigetreten sind, die Nachricht
 \[
  \text{\texttt{PLAYER\_JOINED | <Spielername>}}
 \]
 Sollte ein Spieler zu einem späteren Zeitpunkt ein Spiel verlassen, wird
 \[
  \text{\texttt{PLAYER\_LEFT | <Spielername>}}
 \] 
 geschickt.
 }
 {JOIN\_GAME | CoMa-Testspiel} 

 \clientmessage
 {START\_GAME }
 {0}
 {Wenn man auf dem Server registriert ist und ein Spiel erstellt hat}
 { Startet ein Spiel, was man zuvor erstellt hat. Weitere Spieler können dem Spiel dann nicht mehr beitreten. Läuft das Spiel bereits, anwortet der Server mit
 \[
  \text{\texttt{GAME\_IS\_ALREADY\_RUNNING}}
 \] 
 Der Server fängt dann mit dem Spiel an und schickt an alle mitspielenden Clienten folgende Nachrichten:
 \[
  \text{\texttt{GAME\_STARTED | <Spielname>}}
 \]
 Anschließend wird die Reihenfolge der Spieler zufällig ausgelost, die resultierende Reihenfolge wird den Spielern mittels Nachrichten der Form
 \[
  \text{\texttt{GAME\_PLAYERS | <Spieler1> | <Spieler2> | ...}}
 \] 
 bekannt gegeben. Danach erhalten alle Clienten die Szenario-Daten mittels einer 
 \[
  \text{\texttt{GAME\_STATUS | ...}} 
 \]
 Nachricht. Die Scenario-Daten haben dieselbe Form wie bei \texttt{GET\_SCENARIO}. 
 }
 {START\_GAME} 

 \clientmessage
 {GAME\_CHOICE | <Art der Auswahl> | <Auswahl>}
 {2}
 {Wenn man ein Spiel spielt}
 { Trifft eine vom Server mit
 \[
  \text{\texttt{CHOOSE | <Art der Auswahl> | <Anzahl> | <Option1> | <Option2> | ...}}
 \] 
 angeforderte Auswahl. \texttt{<Art der Auswahl>} muss in dieser Nachricht identisch zu der in der \texttt{CHOOSE}-Nachricht sein. \texttt{<Auswahl>} besteht aus einer durch Kommata getrennten Liste von Zahlen. Die Anzahl der Zahlen in dieser Liste muss der \texttt{<Anzahl>} aus der \texttt{CHOOSE}-Nachricht entsprechen. Die Zahlen werden als Indizes der in der Server-Nachricht gelisteten Optionen interpretiert, wobei 0 der Index der ersten Option ist. Dementsprechend dürfen die Zahlen in der Auswahlliste nur ganze Zahlen zwischen 0 und \# Optionen$-1$ sein; außerdem darf keine Zahl doppelt vorkommen. Der Server gibt die Wahl des Spielers mittels
 \[
  \text{\texttt{CHOSEN | <Spielername> | <Art der Auswahl> | <Gewählte Objekte>}}
 \]
 bekannt. Trifft ein Client eine ungültige Wahl, ignoriert der Server diese und wählt stattdessen zufällig. Antwortet der Client nicht innerhalb einer serverspezifischen Frist auf eine \texttt{CHOOSE}-Nachricht, trifft der Server eine zufällige Auswahl und sendet
 \[
  \text{\texttt{TIMEOUT | <Spielername> | <Art der Auswahl> }}
 \]
 an alle Spieler. Erkennt der Server die vom Client angegebene \texttt{<Art der Auswahl>} nicht, antwortet er mit 
 \[
  \text{\texttt{UNKNOWN\_CHOICE}}
 \]
 Erkennt der Server die Art der Auswahl und erwartet sie zu dem aktuellen Zeitpunkt aber nicht, schickt er
 \[
  \text{\texttt{NOT\_WAITING\_FOR\_THIS\_CHOICE}}
 \]
 zurück. Enthält \texttt{<Auswahl>} etwas ungültiges (z.B. Zeichenketten), wird 
 \[
  \text{\texttt{ILLEGAL\_CHOICE}}
 \]
 zurückgegeben.
 }
 {GAME\_CHOICE | PROGRAMMING | 0,8,3,4,5} 
 
\clearpage 
 
 \clientmessage
 {GET\_SCENARIO | <Szenarioname>}
 {1}
 {Wenn man auf dem Server registriert ist}
 { Fragt ein auf dem Server existierendes Szenario ab. Existiert kein Szenario mit dem angegebenen Namen, antwortet der Server mit
 \[
  \text{\texttt{SCENARIO\_NOT\_FOUND | <Szenarioname>}}
 \]
 Anderenfalls werden Informationen über das Szenario in der Form
 \ama
  &\text{\texttt{SCENARIO | <Name> | <Breite> | <Höhe> | <Schwierigkeit> | <Dauer>}}\\
  &\text{\texttt{| <Min. Spieler> | <Max. Spieler> | <Autor> | <Beschreibung>}}\\
  &\text{\texttt{| <Spielfeld>}} 
 \ema
 geschickt. \texttt{<Name>} ist dabei der Name des Szenarios, \texttt{<Breite>} und \texttt{<Höhe>} sind Breite und Höhe des (immer rechteckigen) Spielfelds. \texttt{<Schwierigkeit>} ist ein vom Author festgelegter Hinweis auf die Schwierigkeit der Strecke (\texttt{EASY}, \texttt{MEDIUM} oder \texttt{EXPERT}); \texttt{<Dauer>} ein Hinweis auf die zum Spielen des Szenarios benötigte Zeit (\texttt{SHORT}, \texttt{MEDIUM} oder \texttt{LONG}). \texttt{Min. Spieler} und \texttt{Max. Spieler} geben die empfohlende Mindestanzahl von Spielern und die maximale Anzahl von Spielern für das Szenario an, es wird nur letztere vom Server erzwungen. \texttt{<Autor>} ist der Ersteller der Karte, \texttt{<Beschreibung>} ist eine vom Autor verfasste Beschreibung der Karte. \texttt{<Spielfeld>} beschreibt schließlich das Spielfeld, siehe dazu den nächsten Abschnitt. 
 }
 {GET\_SCENARIO | Risky Exchange}  
   
 \subsection{Beschreibung des Spielfelds}  
   
Jede Zeile des rechteckigen Spielfelds wird durch ein \texttt{|} terminiert.
 
 Ein Feld des Spielplans besteht aus einem oder mehreren Fabrikelementen, die sich entweder in der Mitte des Feldes oder an einem der vier Ränder (Norden, Osten, Süden, Westen) des Feldes befinden können. Ein Fabrikelement wird durch eine Folge von Großbuchstaben kodiert, die die Art des Fabrikelements angeben. An die Großbuchstaben angehängte Kleinbuchstaben und Zahlen dienen als Parameter für das Fabrikelement.
 
 An Phasen-aktive Elemente können die Ziffern 1-5 angehängt werden um zu beschreiben, in welchen Phasen diese Elemente aktiv sind. \text{\texttt{PU24}} steht z.B. für einen Pusher, der in der 2. und 4. Phase aktiv wird. Band-Elemente wie Förderbänder haben eine Richtung, in der sie Transporieren, welche durch einen Kleinbuchstaben (n,e,s,w für Norden, Osten, Süden, Westen) direkt nach den Großbuchstaben angegeben wird. Werden keine weiteren Kleinbuchstaben angegeben, wird davon ausgegangen, dass das Band aus der gegenüberliegenden Richtung kommt. Ansonsten können die Herkunftsrichtungen durch weitere Kleinbuchstaben beschrieben werden. \texttt{Cwns} ist z.B. ein Förderband, was von Norden und Süden nach Westen transportiert (ein T-Stück also). Die Ziffern der Checkpoints definieren die Reihenfolge, in der die Checkpoints angefahren werden müssen, der erste Checkpoint hat dabei die Nummer 1. Eine Übersicht der Elemente findet sich in der Tabelle.
 
 Besitzt ein Feld mehrere Elemente an derselben Position, z.B. eine Mauer und ein Laser, werden die Elemente durch Leerzeichen getrennt und mit runden Klammern eingeschlossen, in dem Beispiel so: \texttt{(W L)}. 
 
 Die unterschiedlichen Positionen eines Feldes (Mitte, Norden, Osten, Süden, Westen) werden wie folgt dargestellt: zuerst die Mitte, dann die vier Ränder in der Reihenfolge Norden, Osten, Süden, Westen eingeschlossen in eckige Klammern. Ein Feld mit Mauer und Laser in Norden und Westen sowie einer in der ersten Phase aktiven Presse wäre: \texttt{CR1[(W L)\_\_(W L)]}. Ein leeres Feld wäre entsprechend \texttt{\_[\_\_\_\_]}. Für Felder mit leerem Rand gibt es eine Abkürzung -- fehlen die eckigen Klammern nach einem Feld, wird automatisch ein leerer Rand angenommen.
 
 Felder in einer Zeile werden durch Leerzeichen getrennt.   
 
 \begin{table}
 \centering
 \begin{tabular}{|l|l|l|l|l|l|}
  \hline
  Abk. & Zugehöriges Element & Band & Phasen & Rand  & Weitere Parameter\\
  \hline
  \_ & Leer                  & Nein & Nein & Überall & --\\
  \hline
  C  & Förderband            & Ja   & Nein & Mitte   & --\\
  \hline
  CR & Presse                & Nein & Ja   & Mitte   & --\\
  \hline
  CP & Checkpoint            & Nein & Nein & Mitte   & Ziffer von 1-\# Checkpoints\\
  \hline
  E  & Expressförderband     & Ja   & Nein & Mitte   & --\\
  \hline
  G  & Zahnrad               & Nein & Nein & Mitte   & l oder r für die Richtung\\
  \hline
  L  & Laser                 & Nein & Nein & Rand    & --\\
  \hline
  P  & Grube                 & Nein & Nein & Mitte   & --\\
  \hline
  PU & Schieber              & Nein & Ja   & Rand    & --\\
  \hline
  R  & Reparaturfeld         & Nein & Nein & Mitte   & --\\
  \hline
  SP & Startpunkt            & Nein & Nein & Mitte   & Ziffer von 1-\# Spieler\\
  \hline
  U  & Großes Reparaturfeld  & Nein & Nein & Mitte   & --\\
  \hline
  W  & Mauer                 & Nein & Nein & Rand    & --\\
  \hline
 \end{tabular}   
 \end{table}
   
 \subsection{Kommunikation während des Spiels}
 
 Nachdem die Clienten die \texttt{GAME\_STATUS}-Nachrichten erhalten haben, werden sie der Reihe nach mit \texttt{CHOOSE | SPAWN\_DIRECTION} aufgefordert, die Startrichtung für ihren Roboter zu wählen. 
 
 Zu Beginn einer neuen Runde erhalten die Spieler eine \texttt{NEW\_TURN | <Rundennummer>}-Nachricht; abgeschaltete Roboter werden mittels \texttt{CHOOSE | REMAIN\_POWERED\_DOWN} gefragt, ob sie abgeschaltet bleiben wollen. Anschließend erhalten die Roboter ihre Karten und werden per \texttt{CHOOSE | PROGRAMMING} aufgefordert, ihre Programmierung vorzunehmen, was alle Roboter parallel machen. Nachdem die Programmierung abgeschlossen ist, werden die Roboter der Reihe nach per \texttt{CHOOSE | ANNOUNCE\_POWER\_DOWN} gefragt, ob sie sich in der nächsten Runde abschalten wollen.
 
 Danach sendet der Server \texttt{EXECUTING\_PROGRAM\_CARDS} und fängt an, die Programme auszuführen. Vor Beginn jeder Phase sendet er dabei jeweils \texttt{NEW\_PHASE | <Phasennummer>} an die Spieler. Unmittelbar vor dem Ausführen einer Programm-Karte kündigt der Server mittels \texttt{EXECUTE\_PROGRAM\_CARD | <Programm-Karte>} an, was gerade ausgeführt wird. Am Ende jeder Phase und am Ende jeder Runde erhalten alle Spieler den aktuellen Zustand jedes Roboters mittels einer Nachricht der Form:
 \ama
  &\text{\texttt{ROBOT\_STATUS | <Name> | <Lebenspunkte> | <Max. Lebenspunkte>}}\\
  &\text{\texttt{| <Zerstört?> | <Fortschritt> | <Archiv-Feld> | <Aktuelles Feld>}}\\
  &\text{\texttt{| <Richtung> | <Abschalten angekündigt?> | <Abgeschaltet?>}} 
 \ema
 Dabei ist \texttt{<Name>} der Name des Spieler, dem der Roboter gehört; \texttt{<Lebenspunkte>} und \texttt{<Max. Lebenspunkte>} sind die aktuellen und maximalen Lebenspunkte des Roboters. \texttt{<Zerstört?>} gibt an, ob der Roboter zerstört ist, \texttt{<Fortschritt>} gibt die Anzahl erreichter Checkpoints an. \texttt{<Archiv-Feld>} und \texttt{<Aktuelles Feld>} geben die Position der Sicherungskopie und des Roboters an, die Koordinaten haben die Form $(x,y)$, wobei der Ursprung das oberste linke Feld des Spielplans ist. \texttt{<Richtung>} gibt die Richtung des Roboters an (NORTH, EAST, SOUTH, WEST), \texttt{<Abschalten angekündigt?>} und \texttt{<Abgeschaltet?>} genau das, was sie vermuten lassen.
                 
 Wird ein Spieler zerstört (d.h. sein Roboter ist zerstört und er hat keine Leben mehr), wird \texttt{PLAYER\_DESTROYED | <Spielername>} gesendet. Erreicht ein Spieler den letzten Checkpoint, wird \texttt{PLAYER\_ARRIVED | <Spielername>} geschickt. Sobald alle Spieler zerstört oder angekommen sind ist das Spiel vorbei und es wird \texttt{GAME\_OVER | <Spieler1> | <Spieler2> | ...} gesendet, wobei die Spieler in ihrer Ankunfsreihenfolge geordnet sind.
   
\end{document}
